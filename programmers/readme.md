# Lv.1

## 🤖 숫자 문자열과 영단어

(21.07.08)

- 정규표현식을 이용해서 풀려고 했으나, 숫자가 아닌 걸 기준으로 끊다보니 문자열이 연속해서 나왔을 때 못 끊는 문제 발생
- 특정 문자열 자체를 정규표현식에 넣을 수 있다는 것을 떠올리지 못해서 for문으로 해결
- replace와 정규표현식을 이용한다면 간결하고 명확한 풀이 가능

<br>

## 🤖 음양 더하기

(21.07.08)

- 그냥 쉬운 문제

<br>

## 🤖 체육복

(21.07.09)

- 그리디 문제는 어떻게 풀어야 하는 건지 잘 모르겠지만, 그냥 생각나는 로직대로 풀었더니 풀리긴 함

### 시간복잡도

- for문 안에 if문 조건으로 `includes` 사용, if문에서 `filter` 사용 👉 `O(n³)`

### 다른 풀이

- 배열의 특정 요소를 삭제할 때 `filter`를 사용했는데 `splice`를 사용하는 방법도 있다.

<br>
<br>

# Lv.2

## 🤖 문자열 압축

(21.07.06)

- 너무 어렵게 생각한 것 같다. 정규표현식으로 해야 하나? 이런 생각을 했음
- for문만 사용해서 풀 수 있는 문제이고, for문에서 인덱스가 꼭 1씩 증가하지 않아도 된다는 걸 기억하기

<br>

## 🤖 배달

(21.07.07)

- 마을 간의 연결 정보를 2차원 배열로 표현해야겠다고 생각함
- 연결되지 않은 마을로 갈 때, 연결된 마을 중 시간이 적게 걸리는 마을을 선택하는 것은 전체 걸리는 시간이 최소임을 보장해주지 않겠다는 생각을 함
- 도대체 어떻게 푸는 거야..? 😭

### 문제 유형

다익스트라 알고리즘 - 아.. 아직은 나한테 너무 어려운 유형이다. 일단 패스하도록 하자.

<br>

## 🤖 타겟넘버

| Try |   Date   | Time spent | Correctness | Performance | Code |
| :-: | :------: | :--------: | :---------: | :---------: | :--: |
|  1  | 21-07-05 |     ?      |      -      |      -      |  -   |
|  2  | 21-07-21 |     ?      |      -      |      -      |  -   |

(21.07.05)

- 도대체 어떻게 dfs로 풀어야 하는 건지 모르겠다.

(21.07.21)

- 모든 경우를 다 탐색해봐야 하고, 각각의 경우는 배열에서 현재 요소에 다음 요소를 더하거나 빼는 두 가지 경우가 나온다는 점을 인지.
- 따라서 그림으로 그려보면 트리 모양임을 알 수 있음
- BFS로도 가능할 듯 하지만 현재 DFS를 공부하고 있으므로 DFS로 짜보려고 시도
- 트리 모양이니까 재귀로 두 번 호출해야 한다는 것까진 알겠는데,
- 인자를 뭘 넣어야 할 지 모르겠다.
- 배열에서 다음 요소를 어떻게 인자로 넣어야 할 지 모르겠다.
- for문이랑 재귀함수를 혼합시키는 건 아닌 것 같고...

### 포인트

- 왜 DFS/BFS냐?
  - 모든 경우를 다 구해봐야 하는 문제이다. 어떻게 더하고 빼야 타겟 넘버가 될 지 모르니까
  - 각각의 인덱스에 있는 숫자를 더하거나 빼는 두 가지 경우가 존재하는데, 이것을 그려보면 트리 모양이 된다. 그리고 leaf 노드들이 바로 주어진 숫자 배열을 가지고 만든 모든 경우의 수이다.
  - DFS든 BFS든 모든 leaf까지 다 가보고, 타겟 넘버와 일치하는 노드의 개수를 세어 주면 된다.
- 아래 코드를 보면서 이해해보려고 했다. 느낌적인 느낌은 알겠는데 내가 스스로 짤 수 있을까 😭

```js
function solution(numbers, target) {
  var answer = 0;

  function dfs(depth, sum) {
    if (depth === numbers.length) {
      if (sum === target) {
        answer += 1;
      }
      return;
    }
    dfs(depth + 1, sum + numbers[depth]); // 왼쪽
    dfs(depth + 1, sum - numbers[depth]); // 오른쪽
  }

  dfs(0, 0);

  return answer;
}

console.log(solution([1, 1, 1, 1, 1], 3));
```

- 위의 코드는 김태원 선생님이 알려주셨던 if~else랑은 조금 다른 모양이군
- depth를 어떻게 알지? 배열의 원소는 어떻게 가져오지? 이것은 재귀호출 때마다 depth + 1을 해주고 그 depth를 인덱스로 이용해서 배열의 원소를 가져오면 되는 것!
