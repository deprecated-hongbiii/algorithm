# Lv.1

## 🤖 음양 더하기

(21.07.08)

- 그냥 쉬운 문제

<br>

## 🤖 숫자 문자열과 영단어

(21.07.08)

- 정규표현식을 이용해서 풀려고 했으나, 숫자가 아닌 걸 기준으로 끊다보니 문자열이 연속해서 나왔을 때 못 끊는 문제 발생
- 특정 문자열 자체를 정규표현식에 넣을 수 있다는 것을 떠올리지 못해서 for문으로 해결
- replace와 정규표현식을 이용한다면 간결하고 명확한 풀이 가능

<br>
<br>

# Lv.2

## 🤖 문자열 압축

(21.07.06)

- 너무 어렵게 생각한 것 같다. 정규표현식으로 해야 하나? 이런 생각을 했음
- for문만 사용해서 풀 수 있는 문제이고, for문에서 인덱스가 꼭 1씩 증가하지 않아도 된다는 걸 기억하기

<br>

## 🤖 배달

(21.07.07)

- 마을 간의 연결 정보를 2차원 배열로 표현해야겠다고 생각함
- 연결되지 않은 마을로 갈 때, 연결된 마을 중 시간이 적게 걸리는 마을을 선택하는 것은 전체 걸리는 시간이 최소임을 보장해주지 않겠다는 생각을 함
- 도대체 어떻게 푸는 거야..? 😭

### 문제 유형

다익스트라 알고리즘 - 아.. 아직은 나한테 너무 어려운 유형이다. 일단 패스하도록 하자.

<br>

## 🤖 타겟넘버

(21.07.05)

- 도대체 어떻게 dfs로 풀어야 하는 건지 모르겠다.

### 포인트

- 왜 DFS/BFS냐?
  - 모든 경우를 다 구해봐야 하는 문제이다. 어떻게 더하고 빼야 타겟 넘버가 될 지 모르니까
  - 각각의 인덱스에 있는 숫자를 더하거나 빼는 두 가지 경우가 존재하는데, 이것을 그려보면 트리 모양이 된다. 그리고 leaf 노드들이 바로 주어진 숫자 배열을 가지고 만든 모든 경우의 수이다.
  - DFS든 BFS든 모든 leaf까지 다 가보고, 타겟 넘버와 일치하는 노드의 개수를 세어 주면 된다.
- 아래 코드를 보면서 이해해보려고 했다. 느낌적인 느낌은 알겠는데 내가 스스로 짤 수 있을까 😭
```js
function solution(numbers, target) {
  var answer = 0;

  function dfs(depth, sum) {
    if (depth === numbers.length) {
      if (sum === target) {
        answer += 1;
      }
      return;
    }
    dfs(depth + 1, sum + numbers[depth]); // 왼쪽
    dfs(depth + 1, sum - numbers[depth]); // 오른쪽
  }

  dfs(0, 0);

  return answer;
}

console.log(solution([1, 1, 1, 1, 1], 3));
```
