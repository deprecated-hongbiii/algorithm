# Lv.1

## 🤖 상호 평가

(21.08.10)

### 풀이 방법

- 먼저, 반복문 돌 때 이해를 쉽게 하기 위해 2차원 배열의 행과 열을 바꿔준다. (예전에 만들어놓았던 함수를 사용했다.)
- 한 학생이 받은 점수는 이제 행에 담긴 점수들을 보면 된다.
- 반복문 돌면서 볼 건데, 학생 한 명 당 자기자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점인지 판단해야 함
  👉 1. 최고점 또는 최저점인가? 2. 유일한가? - 이렇게 두 가지 체크
  - 만약 그렇다면, 그 점수는 빼고 평균 계산 (studentCount - 1 만큼 나누기)
  - 그렇지 않다면, 모든 점수를 포함하여 평균 계산
- 평균 낸 점수를 점수 구간에 따라 학점으로 바꾸기
- reduce를 사용하여 학점으로 바꾼 string을 계속 붙여나가서 하나의 string으로 리턴

### 감상

- 구현 문제인데 생각한대로 짜고 한 번에 통과해서 기분이 좋았음
- 시간복잡도 측면에서는 똥인듯!
- 메서드 체이닝으로 엄청 간단하게 푼 사람이 있는데 신기할 따름

<br>

## 🤖 숫자 문자열과 영단어

(21.07.08)

- 정규표현식을 이용해서 풀려고 했으나, 숫자가 아닌 걸 기준으로 끊다보니 문자열이 연속해서 나왔을 때 못 끊는 문제 발생
- 특정 문자열 자체를 정규표현식에 넣을 수 있다는 것을 떠올리지 못해서 for문으로 해결
- replace와 정규표현식을 이용한다면 간결하고 명확한 풀이 가능

<br>

## 🤖 음양 더하기

(21.07.08)

- 그냥 쉬운 문제

<br>

## 🤖 체육복

(21.07.09)

- 그리디 문제는 어떻게 풀어야 하는 건지 잘 모르겠지만, 그냥 생각나는 로직대로 풀었더니 풀리긴 함

### 시간복잡도

- for문 안에 if문 조건으로 `includes` 사용, if문에서 `filter` 사용 👉 `O(n³)`

### 다른 풀이

- 배열의 특정 요소를 삭제할 때 `filter`를 사용했는데 `splice`를 사용하는 방법도 있다.

<br>

## 🤖 폰켓몬

(21.07.22)

- pick 마리의 폰켓몬을 선택해야 함
- 처음 든 생각은 nCpick 조합으로 구해야 하나 생각이 듦
- 그 다음 든 생각은 최대한 많은 종류라 함은 pick마리일 테니
- set에 넣어서 size가 pick보다 작거나 같으면 size를 리턴
- size가 pick보다 크면 pick을 리턴하면 될 듯
- 조합 구해야 하는 줄 알고 후덜덜 했는데 Set으로 쉽게 풀리는 문제였다.

<br>
<br>

# Lv.2

## 🤖 괄호 변환

| Try |   Date   | Time spent | Correctness | Performance |                                                      Code                                                       |
| :-: | :------: | :--------: | :---------: | :---------: | :-------------------------------------------------------------------------------------------------------------: |
|  1  | 21-07-26 |     -      |    100%     |      -      | 🔗 [GitHub](https://github.com/dyongdi/algorithm/blob/main/programmers/%EA%B4%84%ED%98%B8%EB%B3%80%ED%99%98.js) |

(21.07.26)

- 그냥 문자열 문제인 줄 알고 도전했는데 재귀였다.. 😨
- 문제에서 제시하는 알고리즘대로 구현만 하면 되는데 재귀 알러지(?)가 있어서 어렵게 느껴졌다.
- 일단 함수로 만들 수 있는 것들을 분리했다. 2개의 "균형잡힌" 으로 분리하는 함수와 "올바른" 인지 체크하는 함수를 만들었다.
- solution 함수 안에서 문제에 나와 있는 알고리즘대로 if문은 구현했으나, else if문에 어떻게 써야할 지 감이 안 왔다.
- [이 블로그](https://gobae.tistory.com/62)를 참고해서 else if문을 구현했더니 문제가 풀어지긴 했다.
- 코드를 써놓고 보니 문제에 나와 있는 의사 코드를 정말 그대로 코드로 옮겨놓은 것 같다는 생각이...
- 하라는대로 구현을 하긴 했지만 재귀가 어떻게 동작하는지는 머리에 샥 그려지진 않는다.
- 만약 문제에 의사 코드가 주어지지 않았다면 나는 이 재귀적인 풀이를 생각해내지 못했을 것 같다.

### 다른 풀이

- 검색해보니 대체적으로 나처럼 함수를 분리하지는 않고 solution 함수 안에서 다 해결하는 코드였다.
- 프로그래머스 '다른 사람의 풀이'에 간결하게 푼 코드가 있는데 잘 이해가 되지 않는다.

```js
function reverse(str) {
  return str
    .slice(1, str.length - 1)
    .split('')
    .map((c) => (c === '(' ? ')' : '('))
    .join('');
}

function solution(p) {
  if (p.length < 1) return '';

  let balance = 0;
  let pivot = 0;
  do {
    balance += p[pivot++] === '(' ? 1 : -1;
  } while (balance !== 0);

  const u = p.slice(0, pivot);
  const v = solution(p.slice(pivot, p.length));

  if (u[0] === '(' && u[u.length - 1] == ')') return u + v;
  else return '(' + v + ')' + reverse(u);
}
```

<br>

## 🤖 문자열 압축

(21.07.06)

- 너무 어렵게 생각한 것 같다. 정규표현식으로 해야 하나? 이런 생각을 했음
- for문만 사용해서 풀 수 있는 문제이고, for문에서 인덱스가 꼭 1씩 증가하지 않아도 된다는 걸 기억하기

<br>

## 🤖 배달

(21.07.07)

- 마을 간의 연결 정보를 2차원 배열로 표현해야겠다고 생각함
- 연결되지 않은 마을로 갈 때, 연결된 마을 중 시간이 적게 걸리는 마을을 선택하는 것은 전체 걸리는 시간이 최소임을 보장해주지 않겠다는 생각을 함
- 도대체 어떻게 푸는 거야..? 😭

### 문제 유형

다익스트라 알고리즘 - 아.. 아직은 나한테 너무 어려운 유형이다. 일단 패스하도록 하자.

<br>

## 🤖 수식최대화

| Try |   Date   | Time spent | Correctness | Performance |                                                           Code                                                           |
| :-: | :------: | :--------: | :---------: | :---------: | :----------------------------------------------------------------------------------------------------------------------: |
|  1  | 21-07-30 | 1시간 40분 |    100%     |      -      | 🔗 [GitHub](https://github.com/dyongdi/algorithm/blob/main/programmers/%EC%88%98%EC%8B%9D%EC%B5%9C%EB%8C%80%ED%99%94.js) |

### 1st try

- 별 생각없이 커밋 reset했더니 썼던 거 다 날아감... 다시 쓰기 귀찮...
- 연산자는 3개, 우선 순위 경우의 수는 6개 뿐이라 모든 경우를 다 구하는 완전탐색 방식으로 풀었다.
- 풀다가 이렇게 푸는 게 진짜 맞는 건가 싶어서 포기할 뻔했는데, 살짝 검색해보니 다들 이렇게 푸는 것 같아서 끝까지 풀어냈다.
- `splice`를 사용해서 연산 결과를 교체해서 넣는 방식을 사용했는데, 결국 값이 하나로 합쳐지기 때문에 `reduce`로도 풀 수 있을 것 같다.
- `findIndex`의 인자는 콜백함수임을 기억하자.

### 문제 해설 (카카오)

연산자의 종류가 최대 3개이므로 연산자 우선순위는 최대 6개까지 나올 수 있습니다. (3! = 6) 연산자 우선순위가 정해지면, 문자열의 앞에서부터 차례대로 우선순위가 빠른 연산자부터 찾아서 그 연산자와 양 옆의 숫자(피연산자) 2개를 제거하고 계산된 결괏값을 대입하는 과정을 반복하면 됩니다.

이때 미리 입력으로 주어진 문자열에서 숫자와 연산자를 분리하여 각각의 배열에 보관해 놓으면 보다 편하게 문제를 해결할 수 있습니다.

숫자에 대한 배열을 준비하고, 연산자에 대한 배열을 준비한 다음, 우선순위에 맞는 연산자의 인덱스를 연산자 배열에서 찾은 후 기억 합니다. 그 후 숫자 배열에서 해당 인덱스와 다음 인덱스를 계산하는 방식을 이용하면 됩니다.

<br>

## 🤖 오픈채팅방

| Try |   Date   | Time spent | Correctness | Performance |                                                           Code                                                           |
| :-: | :------: | :--------: | :---------: | :---------: | :----------------------------------------------------------------------------------------------------------------------: |
|  1  | 21-07-22 |    20분    |    100%     |      -      | 🔗 [GitHub](https://github.com/dyongdi/algorithm/blob/main/programmers/%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9.js) |

(21.07.22)

- 닉네임이 바뀌는 경우는 두 가지.
  - 나갔다가 바꾼 닉네임으로 재입장 (Enter)
  - 채팅방 안에서 변경 (Change)
- userId와 닉네임을 저장하는 자료구조가 필요할 것이라 생각했음
- 객체를 사용해서 key에는 userId, value에는 닉네임을 할당하면 userId가 같을 때는 프로퍼티가 덮어씌워지니까 적절한 자료구조라고 판단
- 마지막에 문제에 주어진 문구대로 바꿀 때 switch문을 사용하려 했으나, Change 커맨드에 대한 처리는 건너뛰어야 하는데 switch 문에서는 continue가 없었다. 빈 문자열로 바꿀까 하다가 그럼 또 필터링을 해줘야 해서 for문으로 처리했다.

### 다른 풀이

- 대체적으로 비슷하게 푼 듯. 내가 인덱스로 하드코딩한 것에 반해 변수로 할당해서 가독성을 높인 코드가 있어서 첨부
- destructuring을 활용한 점이 인상깊다.
- 마지막에 변경된 닉네임만 확인하면 되기 때문에 record 배열을 reverse 했다는 풀이도 봤다. reverse 메서드의 경우 시간복잡도가 `O(N)` 이어서 크게 문제 될 것 같지는 않으나 개인적으로는 객체를 활용한 방식이 더 좋은 것 같다.

```js
function solution(record) {
  const users = {};
  const cmds = [];
  const cmdObj = {
    Enter: "님이 들어왔습니다.",
    Leave: "님이 나갔습니다.",
  };

  for (let rec of record) {
    const [cmd, uid, nickname] = rec.split(" ");
    if (nickname) users[uid] = nickname;
    if (cmd !== "Change") cmds.push([cmd, uid]);
  }

  return cmds.map(([cmd, uid]) => `${users[uid]}${cmdObj[cmd]}`);
```

<br>

## 🤖 타겟넘버

| Try |   Date   | Time spent | Correctness | Performance | Code |
| :-: | :------: | :--------: | :---------: | :---------: | :--: |
|  1  | 21-07-05 |     ?      |      -      |      -      |  -   |
|  2  | 21-07-21 |     ?      |      -      |      -      |  -   |

(21.07.05)

- 도대체 어떻게 dfs로 풀어야 하는 건지 모르겠다.

(21.07.21)

- 모든 경우를 다 탐색해봐야 하고, 각각의 경우는 배열에서 현재 요소에 다음 요소를 더하거나 빼는 두 가지 경우가 나온다는 점을 인지.
- 따라서 그림으로 그려보면 트리 모양임을 알 수 있음
- BFS로도 가능할 듯 하지만 현재 DFS를 공부하고 있으므로 DFS로 짜보려고 시도
- 트리 모양이니까 재귀로 두 번 호출해야 한다는 것까진 알겠는데,
- 인자를 뭘 넣어야 할 지 모르겠다.
- 배열에서 다음 요소를 어떻게 인자로 넣어야 할 지 모르겠다.
- for문이랑 재귀함수를 혼합시키는 건 아닌 것 같고...

### 포인트

- 왜 DFS/BFS냐?
  - 모든 경우를 다 구해봐야 하는 문제이다. 어떻게 더하고 빼야 타겟 넘버가 될 지 모르니까
  - 각각의 인덱스에 있는 숫자를 더하거나 빼는 두 가지 경우가 존재하는데, 이것을 그려보면 트리 모양이 된다. 그리고 leaf 노드들이 바로 주어진 숫자 배열을 가지고 만든 모든 경우의 수이다.
  - DFS든 BFS든 모든 leaf까지 다 가보고, 타겟 넘버와 일치하는 노드의 개수를 세어 주면 된다.
- 아래 코드를 보면서 이해해보려고 했다. 느낌적인 느낌은 알겠는데 내가 스스로 짤 수 있을까 😭

```js
function solution(numbers, target) {
  var answer = 0;

  function dfs(depth, sum) {
    if (depth === numbers.length) {
      if (sum === target) {
        answer += 1;
      }
      return;
    }
    dfs(depth + 1, sum + numbers[depth]); // 왼쪽
    dfs(depth + 1, sum - numbers[depth]); // 오른쪽
  }

  dfs(0, 0);

  return answer;
}

console.log(solution([1, 1, 1, 1, 1], 3));
```

- 위의 코드는 김태원 선생님이 알려주셨던 if~else랑은 조금 다른 모양이군
- depth를 어떻게 알지? 배열의 원소는 어떻게 가져오지? 이것은 재귀호출 때마다 depth + 1을 해주고 그 depth를 인덱스로 이용해서 배열의 원소를 가져오면 되는 것!
