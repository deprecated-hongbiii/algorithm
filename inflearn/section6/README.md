## 1. 올바른 괄호

(21.08.01)

- 쉬운 스택 문제
- 그런데 닫는 괄호가 더 많은 경우를 미처 생각 못 했음. 푸하하..

<br>

## 2. 괄호문자제거

(21.08.01)

- 이것도 쉬운 스택 문제
- `(`, `문자`일 때는 스택에 모두 넣고 `)`일 때는 열린 괄호가 나올 때까지 pop하는 방법도 있다.

<br>

## 3. 크레인 인형뽑기

(21.08.03)

- 개발 공부를 시작한 지 얼마 안 됐을 때 접했던 문제였다. 그 때 당시 며칠동안 붙잡고 겨우겨우 풀었던 기억 때문에 크레인 인형뽑기 게임은 나에게 엄청 어려운 문제라는 인식이 있었다.
- 코드스쿼드 과정 중에 (CS 과정 때였나?) 다시 풀어봤었는데 그 때도 어려웠다.
- 그런데 오늘은!! 30분만에 뚝딱 풀어냈다.
- 사실 한 번에 통과하진 못했다. 대체 로직이 틀린 부분이 없는데 어디가 잘못된 건지 한 30분동안 계속 들여다보고 있었다.
- 알고보니 로직에는 써놓고 코드에서 빼먹은 부분이 있었다.. 후우.. 머리로만 생각하지 말고 글 써놓은 거랑 비교하면서 디버깅을 해야겠다.
  - moves의 원소 하나씩 본다.
  - `board[i][move - 1]`을 i 증가시키며 보는데,
  - 0이 아닌 값이 나오면,
  - stack의 마지막 원소를 확인, 값이 같으면 stack에서 pop한 후 count += 2, board의 해당 값 0으로 바꾸기
  - 값이 다르면 stack에 push한 후 board의 해당 값 0으로 바꾸기

<br>

## 4. 후위식 연산

(21.08.04)

- 후위식 연산이라는 걸 처음 알게 돼서 어떻게 풀어야 할지 살짝 고민하다가 이 챕터가 스택, 큐니까.. 스택으로 푸는 방법이 문득 떠올랐다. 그리고 맞았다.
- 연산자를 배열에 넣어두고 `includes` 메서드를 이용했고, 연산자가 string이기 때문에 함수를 하나 만들어서 switch문으로 분기해서 연산 결과를 리턴해주도록 했다.

### 선생님 풀이

- 선생님은 연산자인지 판단할 때 `isNaN` 을 사용했다.
- 그런데 찾아보니, `전역 isNaN` 의 경우는 `'+'` 와 같은 것들이 true가 나오는데, ES6에서 추가된 `Number.isNaN` 은 더 엄격해서 진짜 `NaN` 일 때만 true가 나온다고 한다.
- 따라서 개인적인 의견으로는 `isNaN` 을 사용하는 게 별로 직관적인 방법은 아닌 것 같다.

```js
function solution(s) {
  let answer;
  let stack = [];
  for (let x of s) {
    if (!isNaN(x)) stack.push(Number(x));
    else {
      let rt = stack.pop();
      let lt = stack.pop();
      if (x === '+') stack.push(lt + rt);
      else if (x === '-') stack.push(lt - rt);
      else if (x === '*') stack.push(lt * rt);
      else if (x === '/') stack.push(lt / rt);
    }
  }
  answer = stack[0];
  return answer;
}

let str = '352+*9-';
console.log(solution(str));
```
